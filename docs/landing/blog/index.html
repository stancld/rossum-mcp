<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' stop-color='%233F8AE2'/%3E%3Cstop offset='100%25' stop-color='%23AE33EC'/%3E%3C/linearGradient%3E%3C/defs%3E%3Cpath stroke='url(%23g)' d='M1.4,10.8c0,0,1-2.2,3.8-3.8c2.8-1.6,5.2-1.4,5.2-1.4 M6.3,20.4c0,0-1.4-1.9-1.4-5.2s1.4-5.2,1.4-5.2M16.6,21.7c0,0-2.4,0.3-5.2-1.4c-2.8-1.6-3.8-3.8-3.8-3.8 M22.6,13.2c0,0-1,2.2-3.8,3.8c-2.8-1.6-5.2,1.4-5.2,1.4 M17.8,3.6c0,0,1.4,1.9,1.4,5.2c0,3.2-1.4,5.2-1.4,5.2 M7.4,2.3c0,0,2.4-0.3,5.2,1.4c2.8,1.6,3.8,3.8,3.8,3.8'/%3E%3C/svg%3E">
  <title>From Friday Hack to Deployable Agent | Rossum MCP & Agent</title>
  <meta name="description" content="500+ commits later, here's what I learned building a production AI agent&mdash;from sub-agents and skills to dynamic tool loading.">
  <meta property="og:title" content="From Friday Hack to Deployable Agent">
  <meta property="og:description" content="500+ commits later, here's what I learned building a production AI agent.">
  <meta property="og:image" content="https://stancld.github.io/rossum-agents/blog/images/hero-agent-orchestration.png">
  <meta property="og:type" content="article">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="From Friday Hack to Deployable Agent">
  <meta name="twitter:description" content="500+ commits later, here's what I learned building a production AI agent.">
  <meta name="robots" content="index, follow">
  <link rel="canonical" href="https://stancld.github.io/rossum-agents/blog/">
  <style>
    :root {
      --primary: #3F8AE2;
      --primary-dark: #2d6bb8;
      --accent: #AE33EC;
      --gradient: linear-gradient(135deg, #3F8AE2, #AE33EC);
      --text: #1a1a2e;
      --text-muted: #4b5563;
      --bg: #ffffff;
      --bg-alt: #f8fafc;
      --border: #e5e7eb;
      --code-bg: #1e1e2e;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      color: var(--text);
      line-height: 1.7;
      background: var(--bg);
    }

    .container { max-width: 780px; margin: 0 auto; padding: 0 1.5rem; }

    /* Header */
    .skip-link {
      position: absolute;
      top: 0;
      left: 0;
      background: var(--primary);
      color: white;
      padding: 0.5rem 1rem;
      z-index: 200;
      text-decoration: none;
      border-radius: 0 0 0.5rem;
      transform: translateY(-100%);
      transition: transform 0.2s;
    }

    .skip-link:focus { transform: translateY(0); }

    body > header {
      padding: 1rem 0;
      border-bottom: 1px solid var(--border);
      position: sticky;
      top: 0;
      background: rgba(255, 255, 255, 0.8);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      z-index: 100;
    }

    @supports not (backdrop-filter: blur(8px)) {
      body > header {
        background: var(--bg);
      }
    }

    body > header.scrolled {
      box-shadow: 0 1px 8px rgba(0, 0, 0, 0.08);
    }

    nav {
      display: flex;
      justify-content: space-between;
      align-items: center;
      max-width: 1100px;
      margin: 0 auto;
      padding: 0 1.5rem;
    }

    .logo {
      font-weight: 700;
      font-size: 1.25rem;
      background: var(--gradient);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-decoration: none;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .logo-icon { width: 1.5rem; height: 1.5rem; }

    .nav-links { display: flex; gap: 2rem; flex-shrink: 0; }

    .nav-links a {
      color: var(--text-muted);
      text-decoration: none;
      font-size: 0.95rem;
      transition: color 0.2s;
      padding: 0.5rem;
      margin: -0.5rem;
    }

    .nav-links a:hover { color: var(--primary); }

    /* Focus states */
    a:focus, button:focus {
      outline: 2px solid var(--primary);
      outline-offset: 2px;
    }

    /* Article */
    article {
      padding: 3rem 0 4rem;
    }

    .article-header {
      text-align: center;
      margin-bottom: 3rem;
      padding-bottom: 2rem;
      border-bottom: 1px solid var(--border);
    }

    .article-header h1 {
      font-size: 2.5rem;
      font-weight: 700;
      line-height: 1.2;
      margin-bottom: 1rem;
      letter-spacing: -0.02em;
    }

    .article-subtitle {
      font-size: 1.25rem;
      color: var(--text-muted);
      font-style: italic;
    }

    .author-byline {
      font-size: 0.95rem;
      color: var(--text-muted);
      margin-top: 1rem;
    }

    .hero-image {
      margin: 2rem 0 3rem;
      border-radius: 1rem;
      overflow: hidden;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
    }

    .hero-image img {
      width: 100%;
      height: auto;
      display: block;
    }

    /* Content */
    h2 {
      font-size: 1.5rem;
      font-weight: 700;
      margin: 3rem 0 1rem;
      padding-top: 1rem;
      border-top: 1px solid var(--border);
      scroll-margin-top: 5rem;
    }

    h2:first-of-type {
      border-top: none;
      padding-top: 0;
    }

    p {
      margin-bottom: 1.25rem;
      color: var(--text);
    }

    a {
      color: var(--primary);
      text-decoration: none;
    }

    a:hover {
      text-decoration: underline;
    }

    .pr-link {
      display: inline-block;
      background: linear-gradient(135deg, rgba(63, 138, 226, 0.1), rgba(174, 51, 236, 0.1));
      border: 1px solid rgba(63, 138, 226, 0.2);
      padding: 0.35rem 0.75rem;
      border-radius: 6px;
      font-size: 0.85rem;
      font-weight: 500;
      margin-bottom: 1rem;
    }

    pre {
      background: var(--code-bg);
      color: #cdd6f4;
      padding: 1.25rem 1.5rem;
      border-radius: 0.75rem;
      overflow-x: auto;
      font-family: 'SF Mono', Monaco, 'Courier New', monospace;
      font-size: 0.875rem;
      line-height: 1.6;
      margin: 1.5rem 0;
    }

    code {
      font-family: 'SF Mono', Monaco, 'Courier New', monospace;
      font-size: 0.9em;
      background: var(--bg-alt);
      padding: 0.15rem 0.4rem;
      border-radius: 4px;
    }

    pre code {
      background: none;
      padding: 0;
    }

    .code-comment { color: #6c7086; }
    .code-keyword { color: #cba6f7; }
    .code-string { color: #a6e3a1; }
    .code-decorator { color: #f9e2af; }

    /* Badge (matches landing page) */
    .badge {
      display: inline-block;
      background: linear-gradient(135deg, rgba(63, 138, 226, 0.1), rgba(174, 51, 236, 0.1));
      border: 1px solid rgba(63, 138, 226, 0.2);
      padding: 0.5rem 1.25rem;
      border-radius: 9999px;
      font-size: 0.85rem;
      color: var(--primary);
      font-weight: 500;
    }

    .badge.wip {
      background: linear-gradient(135deg, rgba(251, 191, 36, 0.15), rgba(245, 158, 11, 0.15));
      border-color: rgba(245, 158, 11, 0.3);
      color: #b45309;
    }

    /* TL;DR navigation */
    .toc {
      background: linear-gradient(135deg, rgba(63, 138, 226, 0.03), rgba(174, 51, 236, 0.03));
      border: 1px solid var(--border);
      border-radius: 1rem;
      padding: 1.75rem 2rem;
      margin: 0 0 3rem;
      position: relative;
      overflow: hidden;
    }

    .toc::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: var(--gradient);
    }

    .toc h2 {
      font-size: 0.85rem;
      margin: 0 0 1.25rem;
      padding: 0;
      border: none;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.1em;
      font-weight: 600;
    }

    .toc ol {
      margin: 0;
      padding: 0;
      list-style: none;
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 0.5rem 2rem;
      counter-reset: list-item;
    }

    .toc li {
      padding: 0.4rem 0;
      font-size: 0.95rem;
      display: flex;
      align-items: baseline;
      gap: 0.5rem;
    }

    .toc li::before {
      counter-increment: list-item;
      content: counter(list-item);
      font-size: 0.75rem;
      font-weight: 700;
      color: var(--primary);
      background: rgba(63, 138, 226, 0.1);
      width: 1.5rem;
      height: 1.5rem;
      border-radius: 50%;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .toc a {
      color: var(--text);
      text-decoration: none;
      transition: color 0.2s;
    }

    .toc a:hover {
      color: var(--primary);
    }

    @media (max-width: 600px) {
      .toc ol { grid-template-columns: 1fr; }
      .toc { padding: 1.25rem 1.5rem; }
    }

    /* CTA box */
    .cta-box {
      text-align: center;
      margin: 3rem 0 0;
      padding: 2rem;
      background: linear-gradient(135deg, rgba(63, 138, 226, 0.05), rgba(174, 51, 236, 0.05));
      border-radius: 1rem;
      border: 1px solid var(--border);
    }

    .cta-box p {
      color: var(--text-muted);
      font-style: italic;
      margin-bottom: 1.5rem;
    }

    .cta-button {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      background: var(--gradient);
      color: white;
      padding: 0.9rem 2rem;
      border-radius: 9999px;
      font-weight: 500;
      text-decoration: none;
      transition: all 0.2s;
      box-shadow: 0 4px 14px rgba(63, 138, 226, 0.3);
    }

    .cta-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(63, 138, 226, 0.4);
      text-decoration: none;
    }

    .cta-button svg {
      flex-shrink: 0;
    }

    blockquote {
      border-left: 4px solid var(--primary);
      padding: 1rem 1.5rem;
      margin: 2rem 0;
      background: linear-gradient(135deg, rgba(63, 138, 226, 0.05), rgba(174, 51, 236, 0.05));
      border-radius: 0 0.5rem 0.5rem 0;
      font-size: 1.1rem;
      font-style: italic;
      color: var(--text);
    }

    /* Takeaway boxes */
    .takeaway {
      background: var(--bg-alt);
      border: 1px solid var(--border);
      border-radius: 0.75rem;
      padding: 1rem 1.25rem;
      margin: 1.5rem 0;
    }

    .takeaway strong {
      color: var(--primary);
    }

    /* Images */
    .content-image {
      margin: 2rem 0;
      border-radius: 0.75rem;
      overflow: hidden;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
      border: 1px solid var(--border);
    }

    .content-image img {
      width: 100%;
      height: auto;
      display: block;
    }

    .content-image figcaption {
      padding: 0.75rem 1rem;
      background: var(--bg-alt);
      font-size: 0.9rem;
      color: var(--text-muted);
      text-align: center;
      font-style: italic;
    }

    /* Architecture diagram */
    .arch-diagram {
      background: var(--bg-alt);
      border: 1px solid var(--border);
      border-radius: 0.75rem;
      padding: 1.5rem;
      margin: 1.5rem 0;
      text-align: center;
      font-family: 'SF Mono', Monaco, 'Courier New', monospace;
      font-size: 0.9rem;
      line-height: 1.8;
    }

    .arch-diagram .level-1 { color: var(--primary); font-weight: 600; }
    .arch-diagram .level-2 { color: var(--text-muted); margin-left: 1.5rem; }

    /* Footer */
    footer {
      padding: 3rem 0;
      border-top: 1px solid var(--border);
      text-align: center;
      color: var(--text-muted);
      font-size: 0.9rem;
    }

    footer .disclaimer {
      font-size: 0.85rem;
      font-style: italic;
      margin-bottom: 0.75rem;
      opacity: 0.8;
    }

    footer a {
      color: var(--text-muted);
      text-decoration: underline;
      transition: color 0.2s;
    }

    footer a:hover { color: var(--primary); }

    /* Responsive */
    @media (max-width: 768px) {
      .article-header h1 { font-size: 1.75rem; }
      .article-subtitle { font-size: 1.1rem; }
      h2 { font-size: 1.25rem; }
      pre { font-size: 0.8rem; padding: 1rem; }
      blockquote { padding: 0.75rem 1rem; font-size: 1rem; }
    }

    @media (max-width: 480px) {
      .container { padding: 0 1rem; }
      article { padding: 2rem 0 3rem; }
      .nav-links { gap: 1rem; font-size: 0.9rem; }
    }

    /* Print styles */
    @media print {
      body > header, .skip-link { display: none; }
      body { font-size: 12pt; }
      article { padding: 1rem 0; }
      .hero-image, .content-image { box-shadow: none; border: 1px solid #ccc; }
      .arch-diagram { background: none; border: 1px solid #ccc; }
      pre { white-space: pre-wrap; word-wrap: break-word; }
      a { text-decoration: underline; }
      a[href^="http"]::after { content: " (" attr(href) ")"; font-size: 0.8em; }
    }
  </style>
</head>
<body>
  <a href="#main" class="skip-link">Skip to main content</a>
  <header>
    <nav>
      <a href="../" class="logo" aria-label="Rossum MCP & Agent home">
        <svg class="logo-icon" viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" xmlns="http://www.w3.org/2000/svg">
          <defs>
            <linearGradient id="logo-icon-gradient" x1="0%" y1="0%" x2="100%" y2="100%">
              <stop offset="0%" stop-color="#3F8AE2"/>
              <stop offset="100%" stop-color="#AE33EC"/>
            </linearGradient>
          </defs>
          <path stroke="url(#logo-icon-gradient)" d="M1.4,10.8c0,0,1-2.2,3.8-3.8c2.8-1.6,5.2-1.4,5.2-1.4 M6.3,20.4c0,0-1.4-1.9-1.4-5.2s1.4-5.2,1.4-5.2M16.6,21.7c0,0-2.4,0.3-5.2-1.4c-2.8-1.6-3.8-3.8-3.8-3.8 M22.6,13.2c0,0-1,2.2-3.8,3.8c-2.8,1.6-5.2,1.4-5.2,1.4 M17.8,3.6c0,0,1.4,1.9,1.4,5.2c0,3.2-1.4,5.2-1.4,5.2 M7.4,2.3c0,0,2.4-0.3,5.2,1.4c2.8,1.6,3.8,3.8,3.8,3.8"/>
        </svg>
        Rossum MCP & Agent
      </a>
      <div class="nav-links">
        <a href="https://github.com/stancld/rossum-agents" target="_blank" rel="noopener">GitHub</a>
        <a href="../source/">Docs</a>
        <a href="../">Home</a>
      </div>
    </nav>
  </header>

  <main id="main">
    <article class="container">
      <header class="article-header">
        <h1>From Friday Hack to Deployable Agent</h1>
        <p class="article-subtitle">500+ commits later, here's what I learned.</p>
        <p class="author-byline">By Dan Stancl</p>
      </header>

      <figure class="hero-image">
        <img src="./images/hero-agent-orchestration.png" alt="AI Agent orchestration diagram showing how the main agent coordinates with sub-agents, skills, and tools" loading="eager">
      </figure>

      <p>You've built an AI agent that works. It calls APIs, follows instructions, and nails your cherry-picked example. Then someone asks a slightly different question, and it gets stuck on the same step until it gives up or hallucinates.</p>

      <p>It started as a Friday hack: a small MCP server, a handful of tools, and that dopamine hit when the LLM successfully called an API for the first time. I showed it to colleagues. They'd nod and ask: "Can it also debug this crashing webhook?" And it would fail. Every conversation revealed another gap. The goal shifted from flashy demos to the tedious stuff that actually ships, such as configuring extensions or analyzing failing webhooks.</p>

      <p>This post is about the gap between "toy demo" and "something that survives user testing." I've been building an agent for <a href="https://rossum.ai" target="_blank" rel="noopener">Rossum</a>, but the lessons apply everywhere. They're about sub-agents, dynamic tool loading, prompt regression testing, and the dozen decisions that separate a demo from a deployable system.</p>

      <p>If you're building agents with tool calling, <a href="https://modelcontextprotocol.io/docs/getting-started/intro" target="_blank" rel="noopener">Model Context Protocol (MCP)</a> servers, or multi-model orchestration, this is the stuff I wish I'd known earlier. The biggest surprise? When I upgraded to a smarter model, my prompts got 70% shorter and the agent got much more clever.</p>

      <p>Making an agent work once is easy. Making it work <strong>reliably for the next person's question</strong>? That's the actual job.</p>

      <nav class="toc" aria-label="Table of contents">
        <h2>Lessons at a Glance</h2>
        <ol>
          <li><a href="#section-1">Let Type Hints Define Your Tools</a></li>
          <li><a href="#section-2">From Smolagents to Claude Agent SDK</a></li>
          <li><a href="#section-3">Embed Agent's UI Where the Work Happens</a></li>
          <li><a href="#section-4">Sub-Agents for Context Isolation</a></li>
          <li><a href="#section-5">Skills: Load Knowledge Just-in-Time</a></li>
          <li><a href="#section-6">Dynamic Tool Loading</a></li>
          <li><a href="#section-7">Smarter Models Need Simpler Prompts</a></li>
          <li><a href="#section-8">Regression Testing: Prompts Need Tests Too</a></li>
          <li><a href="#section-9">Orchestrate Specialists</a></li>
        </ol>
      </nav>

      <h2 id="section-1">1. Let Type Hints Define Your Tools</h2>

      <a href="https://github.com/stancld/rossum-agents/pull/56" class="pr-link" target="_blank" rel="noopener">PR #56</a>

      <p>My first tool layer looked like many backend systems: handler classes inheriting from a base, scattered across 10 files, each with its own registration boilerplate. Adding a new tool meant touching multiple files and trying to remember where the logic lived.</p>

      <p>I replaced it with <strong><a href="https://github.com/jlowin/fastmcp" target="_blank" rel="noopener">FastMCP</a></strong>, a declarative framework where a single decorator defines the entire tool contract:</p>

<pre><span class="code-comment"># Before: manual Tool definition with hand-written JSON schema</span>
<span class="code-keyword">class</span> QueuesHandler(BaseHandler):
    <span class="code-decorator">@classmethod</span>
    <span class="code-keyword">def</span> get_tool_definitions(cls) -> list[Tool]:
        <span class="code-keyword">return</span> [
            Tool(
                name=<span class="code-string">"list_queues"</span>,
                description=<span class="code-string">"List all queues with optional filters."</span>,
                inputSchema={
                    <span class="code-string">"type"</span>: <span class="code-string">"object"</span>,
                    <span class="code-string">"properties"</span>: {
                        <span class="code-string">"workspace_id"</span>: {<span class="code-string">"type"</span>: [<span class="code-string">"integer"</span>, <span class="code-string">"null"</span>]},
                        <span class="code-string">"name"</span>: {<span class="code-string">"type"</span>: [<span class="code-string">"string"</span>, <span class="code-string">"null"</span>]},
                    },
                },
            ),
            ...
        ]</pre>

<pre><span class="code-comment"># After: type hints ARE the schema</span>
<span class="code-decorator">@mcp.tool</span>(description=<span class="code-string">"List all queues with optional filters."</span>)
<span class="code-keyword">async def</span> list_queues(workspace_id: int | None = None, name: str | None = None) -> list[Queue]:
    ...</pre>

      <p><strong>The type hints become the JSON schema the LLM sees.</strong> The description tells the agent when to use it. FastMCP turns a Python signature into an API contract automatically.</p>

      <div class="takeaway"><strong>Takeaway:</strong> -2,011 lines. When types are the schema, there's nothing left to document.</div>

      <h2 id="section-2">2. From Smolagents to the Claude Agent SDK</h2>

      <a href="https://github.com/stancld/rossum-agents/pull/57" class="pr-link" target="_blank" rel="noopener">PR #57</a>

      <p>My initial stack used <strong><a href="https://huggingface.co/docs/smolagents" target="_blank" rel="noopener">smolagents</a></strong> (Hugging Face's library for building agents in a few lines of code) and <strong><a href="https://www.litellm.ai/" target="_blank" rel="noopener">LiteLLM</a></strong> (a unified interface for swapping between OpenAI, Anthropic, and other providers). My first working prototype took an afternoon.</p>

      <p>But "afternoon prototype" and "production-ready" live in different zip codes. As requirements grew, I needed lower-level control:</p>
      <ul style="margin: 0.5rem 0 1.25rem 1.5rem;">
        <li><strong>Native async/await</strong> for cleaner streaming to the FastAPI frontend</li>
        <li><strong>Direct tool calling</strong>â€”smolagents defaults to "code-agent" mode, where the LLM writes Python to invoke tools. That's powerful for complex orchestration, but my use case was simpler: wrap API calls and validate inputs. When the model generates code, you're debugging Python. When it emits structured JSON that maps to function signatures, you're validating data. For straightforward API wrappers, the latter is easier to constrain and test.</li>
        <li><strong>Full visibility into system prompts</strong> for debugging and iteration</li>
      </ul>
      <p>I migrated to the <strong><a href="https://platform.claude.com/docs/en/agent-sdk/overview" target="_blank" rel="noopener">Claude Agent SDK</a></strong> with direct Bedrock integration (AWS's managed Claude service). The SDK handles streaming, tool schemas, and multi-turn context natively. Along the way, I deleted 1,500+ lines of custom file and analysis toolsâ€”things like Mermaid diagram generationâ€”that modern Claude models now handle out of the box. More capabilities, less code.</p>

      <div class="takeaway"><strong>Takeaway:</strong> High-level frameworks accelerate prototyping. When workarounds outnumber features, move closer to the provider SDK.</div>

      <h2 id="section-3">3. Embed Agent's UI Where the Work Happens</h2>

      <a href="https://github.com/stancld/rossum-agents/pull/58" class="pr-link" target="_blank" rel="noopener">PR #58</a>

      <p>The agent started as a <strong>CLI script</strong>. It worked great for engineers, but for a support engineer, solution architect, or account manager, "clone the repo and configure your environment variables" isn't a feature. It's a roadblock.</p>

      <p>So I built a <strong>dedicated chat app</strong> (using <a href="https://streamlit.io/" target="_blank" rel="noopener">Streamlit</a>). It lowered the barrier, but introduced new friction: context-switching. Users had to jump between tabs, re-authenticate, and manually bridge the gap between the agent and the Rossum platform.</p>

      <p>What actually worked was <strong>embedding the chat</strong> directly into the Rossum UI as a native panel. The agent now inherits the user's context and permissions. No more switching tabs, no re-authentication. The technical implementationâ€”a <a href="https://fastapi.tiangolo.com/" target="_blank" rel="noopener">FastAPI</a> backendâ€”was the easy part. The insight was realizing that proximity to the user's workflow matters more than feature completeness.</p>

      <div class="takeaway"><strong>Takeaway:</strong> If the user has to leave their workflow to use your agent, they'll eventually stop using it.</div>

      <figure class="content-image">
        <img src="../images/fabry_analysis.png" alt="Mr. Fabry analyzing a document workflow, showing queue configuration and active extensions in real-time" loading="lazy">
        <figcaption>Mr. Fabryâ€”named after the engineer in Karel ÄŒapek's <em>R.U.R.</em>, the play that gave us the word "robot"â€”explaining queue configuration and active extensions in real-time</figcaption>
      </figure>

      <h2 id="section-4">4. Sub-Agents for Context Isolation</h2>

      <a href="https://github.com/stancld/rossum-agents/pull/107" class="pr-link" target="_blank" rel="noopener">PR #107</a>
      <a href="https://code.claude.com/docs/en/sub-agents" class="pr-link" target="_blank" rel="noopener">Sub-Agents</a>

      <p>Early on, I treated the agent like a single specialist locked in a room with every tool I could provide. I assumed that because Rossum is a specialized domain, one well-prompted agent could handle the entire API surface.</p>

      <p>The real issue was <strong>context pollution</strong>. Rossum workflows use large schemas, tens to hundreds of fields, which quickly overwhelm a context window.</p>

      <p>Complex tasks require messy iteration: retrying a failing webhook, patching a schema multiple times, digging through documentation. In a monolithic architecture, every failed attempt and verbose API error accumulates in the conversation. The noise drowns out the signal.</p>

      <p>The solution: <strong>delegation with isolation.</strong></p>

      <p>Sub-agents are separate LLM calls with their own conversation history and a restricted toolset. They iterate, fail, and retry in a sandbox, then return only the result to the main agent. The main agent never sees the 50 lines of API errors it took to get there.</p>

      <p>I chose sub-agents for tasks that either required many retries (like debugging webhooks) or produced verbose intermediate outputs (like knowledge base searches). The primary conversation stays clean:</p>

      <figure class="arch-diagram" role="img" aria-label="Architecture diagram showing Main Agent (Opus 4.5) delegating to three sub-agents: HookDebugSubAgent for serverless function failures, SchemaPatchingSubAgent for JSON schema modifications, and KnowledgeBaseSubAgent for documentation retrieval">
        <div class="level-1">Main Agent (Opus 4.5)</div>
        <div class="level-2">â”œâ”€â”€ HookDebugSubAgent (serverless function failures)</div>
        <div class="level-2">â”œâ”€â”€ SchemaPatchingSubAgent (JSON schema modifications)</div>
        <div class="level-2">â””â”€â”€ KnowledgeBaseSubAgent (documentation retrieval)</div>
      </figure>

      <p>Implementation: sub-agents are exposed as regular tools. Calling <code>debug_hook</code> spawns a separate LLM session with its own history, restricted toolset, and focused system prompt. An abstract base class handles the iteration loop; concrete implementations define their tools and execution logic. The 15 iterations of trial-and-error stay quarantined.</p>

      <div class="takeaway"><strong>Takeaway:</strong> Sub-agents aren't just for specialization. They're garbage collection for your context window.</div>

      <h2 id="section-5">5. Skills: Load Knowledge Just-in-Time</h2>

      <a href="https://github.com/stancld/rossum-agents/pull/73" class="pr-link" target="_blank" rel="noopener">PR #73</a>
      <a href="https://platform.claude.com/docs/en/agents-and-tools/agent-skills/overview" class="pr-link" target="_blank" rel="noopener">Agent Skills</a>

      <p>Initially, the agent's "brain" was a monolithic system prompt. I kept adding rules, edge cases, and <code>IMPORTANT:</code> blocks in all caps. It felt productive until it became brittle, unreadable, and expensive. Loading every format specification and workflow upfront meant I was paying for tokens the agent didn't even need for 90% of tasks.</p>

      <p>I pivoted to a <strong>Skills Framework</strong>: show only what's necessary. Rossum's documentation spans hundreds of pages; loading it upfront would consume half the context window. Instead, the system loads expertise when it becomes relevant.</p>

      <figure class="content-image">
        <img src="./images/skills-modular.png" alt="Skills as modular units - showing individual skill files that can be loaded on demand" loading="lazy">
        <figcaption>Skills as modular, version-controlled prompt units</figcaption>
      </figure>

<pre>skills/
â”œâ”€â”€ hook-debugging.md       <span class="code-comment"># Debugging serverless hook issues</span>
â”œâ”€â”€ organization-setup.md   <span class="code-comment"># New customer setup with regional templates</span>
â”œâ”€â”€ rossum-deployment.md    <span class="code-comment"># Safe deployment via sandbox with diffs</span>
â”œâ”€â”€ schema-patching.md      <span class="code-comment"># Adding and updating individual fields</span>
â”œâ”€â”€ schema-pruning.md       <span class="code-comment"># Tree-based view for removing unused fields</span>
â””â”€â”€ ui-settings.md          <span class="code-comment"># Configuring annotation list columns</span></pre>

      <p>The system operated in two distinct stages to optimize the context window:</p>
      <ul style="margin: 1rem 0 1.5rem 1.5rem;">
        <li>Metadata (always loaded): short descriptions of each skill. These act as "triggers" so the agent knows what expertise is available.</li>
        <li>Instructions (loaded on demand): the full procedural knowledge injected only when the agent identifies a matching task, i.e., examples, patterns, and constraints.</li>
      </ul>

      <p>If a user asks "Why is my webhook failing?", the agent identifies the <code>hook-debugging</code> metadata and pulls in the full instructions. Knowledge for UI settings and schema patching stays dormant.</p>

      <p>Adding a capability is now a standard software task: create a file, version it, ship it. Product managers draft skills in Markdown; engineers review them like code.</p>

      <div class="takeaway"><strong>Takeaway:</strong> Stop trying to teach the agent everything at once. Give it a table of contents and let it read the chapter it needs.</div>

      <h2 id="section-6">6. Dynamic Tool Loading Cuts Context Costs</h2>

      <a href="https://github.com/stancld/rossum-agents/pull/108" class="pr-link" target="_blank" rel="noopener">PR #108</a>

      <p>As the toolkit expanded, I hit the "Agent Tax": every tool costs tokens even if never called. Loading 50+ MCP tools upfront burned <strong>8,000 tokens</strong> before the user typed a word.</p>

      <p>To solve this, I implemented a <strong>Two-Phase Dynamic Loading</strong> strategy:</p>

      <ul style="margin: 1rem 0 1.5rem 1.5rem;">
        <li>Phase 1: Keyword heuristics. When a message arrived, a simple regex scan in Python checked the user's prompt for domain-specific keywords (e.g., "webhook," "schema," "queue"), bypassing the LLM and relying on old-school pattern matching. The system pre-loaded the corresponding tool categories to eliminate "cold-start" delays. The agent started the conversation with the right tools already in hand.</li>
        <li>Phase 2: Just-in-time discovery. For complex or ambiguous requests, the agent used two "meta-tools" to explore the rest of the library:
          <ul style="margin: 0.5rem 0 0 1rem; list-style-type: circle;">
            <li><code>list_tool_categories()</code>: show me the available tool groups.</li>
            <li><code>get_tool_category(name)</code>: load the specific tools for this group.</li>
          </ul>
        </li>
      </ul>

      <p>"List my queues" now loads only queue-related tools (~800 tokens) instead of the full 8,000-token library. <strong>10x reduction</strong> in baseline context.</p>

      <p>The real surprise was quality. With fewer tools to choose from, the model stopped second-guessing itself. Turns out, removing noise from the toolset was as effective as better prompting.</p>

      <div class="takeaway"><strong>Takeaway:</strong> A crowded context window is a distracted agent. Dynamic loading saves money and improves reasoning.</div>

      <h2 id="section-7">7. Smarter Models Need Simpler Prompts</h2>

      <a href="https://github.com/stancld/rossum-agents/pull/99" class="pr-link" target="_blank" rel="noopener">PR #99</a>
      <a href="https://github.com/anthropics/claude-code/tree/main/plugins/claude-opus-4-5-migration" class="pr-link" target="_blank" rel="noopener">Opus 4.5 Migration Plugin</a>

      <p>Switching models usually feels like a simple configuration change. But moving from Sonnet to <strong>Claude Opus 4.5</strong> taught me that better models require better, and often <em>shorter</em>, instructions. My prompt had become an over-engineered legal document, and I had to admit it.</p>

      <p>The initial migration was rough. Opus fell into the "tool-calling inferno": redundant loops where the model over-analyzed simple tasks, burning tokens without progress. I realized the problem wasn't the model; it was my "legacy" prompts. Building with less capable models had trained me to write exhaustive, hand-holding instructions. Because Opus 4.5 is more literal and responsive, my <code>CRITICAL:</code> and <code>MUST:</code> blocks were being treated as absolute commands to act, even when unnecessary.</p>

      <p>The fix: stop writing procedures, start writing goals.</p>

<pre><span class="code-comment"># Before: 104 lines of step-by-step handholding</span>
### Step 4: Hook Code Debugging with Opus

**MANDATORY**: When debugging Python hook code, you MUST use `debug_hook`.

**CRITICAL: Investigate ALL Issues**
- DO NOT stop at the first issue found
- The Opus sub-agent will exhaustively analyze for ALL issues
- Continue investigating even after fixing one error

### Step 5: Trust and Apply Opus Results
**CRITICAL:**
- When Opus returns fixed code, you MUST trust its findings
- DO NOT second-guess or re-analyze what Opus has investigated
- DO NOT simplify or modify the fixed code Opus provides

<span class="code-comment"># After: 31 lines of goals + constraints</span>
# Hook Debugging Skill

**Goal**: Identify and fix hook issues.

| Tool | Purpose |
|------|---------|
| `search_knowledge_base` | **USE FIRST** - contains extension configs |
| `debug_hook(hook_id, annotation_id)` | Spawns sub-agent for code analysis |

**Constraints**:
- Always search knowledge base first
- Use `debug_hook` for Python code--do not analyze yourself
- Trust `debug_hook` results--do not re-analyze or modify</pre>

      <p>The hook-debugging skill shrunk from 104 lines to 31. I stopped telling Opus <em>how</em> to think and started telling it <em>what the desired outcome</em> looks like.</p>

      <p>By softening the aggressive language and letting the model infer the best path from the available constraints, I eliminated the tool loops. Counter-intuitively, the model became more predictable.</p>

      <div class="takeaway"><strong>Takeaway:</strong> Smarter models need simpler prompts. If your agent is over-triggering tools or getting stuck, you're likely micromanaging it.</div>

      <h2 id="section-8">8. Regression Testing: Prompts Need Tests Too</h2>

      <a href="https://github.com/stancld/rossum-agents/pull/82" class="pr-link" target="_blank" rel="noopener">PR #82</a>

      <p>Refactoring a prompt can change system behavior as much as changing business logic. Every "improvement" is a potential regression.</p>

      <p>Consider a typical week: Monday, you tweak the system prompt for better clarity. Tuesday, you add a new validation tool. Wednesday, you "optimize" a tool description. By Friday, the agent is hallucinating parameters or skipping critical steps. Without a way to measure <em>precisely</em> what changed, you're debugging by intuition.</p>

      <p>Intuition doesn't scale, so I built an <strong>Evaluation Framework</strong>. It runs the agent through realistic scenarios and validates behavior:</p>

<pre>RegressionTestCase(
    name=<span class="code-string">"setup_invoice_queue_with_validation"</span>,
    prompt=<span class="code-string">"Set up Invoice queue with three specific business validation checks..."</span>,
    tool_expectation=ToolExpectation(
        expected_tools=[
            <span class="code-string">"create_queue_from_template"</span>,
            <span class="code-string">"search_knowledge_base"</span>,
            <span class="code-string">"create_hook_from_template"</span>,
        ],
        mode=ToolMatchMode.SUBSET,
    ),
    token_budget=TokenBudget(
        min_total_tokens=60000,  <span class="code-comment"># Guard against "lazy" agent shortcuts</span>
        max_total_tokens=90000,  <span class="code-comment"># Detect infinite loops early</span>
    ),
    success_criteria=SuccessCriteria(
        require_subagent=True,
        max_steps=6,
        custom_checks=[BUSINESS_VALIDATION_HOOK_CHECK],
    ),
)</pre>

      <p>By tracking <strong>tool sequences</strong> and <strong>token budgets</strong>, I caught subtle regressions that a simple "check the output" test would miss:</p>

      <ul style="margin: 1rem 0 1.5rem 1.5rem;">
        <li><strong>The silent skip:</strong> After refactoring a skill prompt, the agent stopped calling <code>search_knowledge_base</code> before debugging hooks. The output looked fine, but the agent was guessing instead of consulting documentation. The test caught the missing tool in the expected sequence.</li>
        <li><strong>The infinite loop:</strong> A "clarified" tool description caused the agent to call <code>get_schema</code> repeatedly, convinced each response was incomplete. Token budget alerts flagged it before I burned through $50 in a single test run.</li>
      </ul>

      <p>Neither failure was obvious from reading the output. The agent completed its task; it just took a worse path. Without quantitative checks, I'd have shipped regressions disguised as improvements.</p>

      <div class="takeaway"><strong>Takeaway:</strong> If you can't measure the impact of a prompt change, you shouldn't ship it.</div>

      <h2 id="section-9">9. Orchestrate Specialists, Don't Replicate Them</h2>

      <a href="https://github.com/stancld/rossum-agents/commit/59e0881" class="pr-link" target="_blank" rel="noopener">Commit 59e0881</a>
      <a href="https://knowledge-base.rossum.ai/docs/formula-fields-in-rossum" class="pr-link" target="_blank" rel="noopener">Formula Fields in Rossum</a>

      <p><a href="#section-4">Section 4</a> introduced sub-agents for context isolation. This section goes further: instead of spawning another instance of the same frontier model, the agent hands off work to an <strong>existing production system</strong>.</p>

      <p>Rossum uses <a href="https://knowledge-base.rossum.ai/docs/formula-fields-in-rossum" target="_blank" rel="noopener">Formula Fields</a> for computing derived values during document extraction. Formulas are written in <strong><a href="https://pypi.org/project/txscript/" target="_blank" rel="noopener">TxScript</a></strong>, a language based on Python but extended with Rossum-specific functions, variables, and field references. Rossum already has a production <strong>Formula Field Copilot</strong>: an LLM prompted to translate natural language into precise TxScript.</p>

      <p>So why not have Opus generate formulas directly? Since TxScript is Python-based, Opus can write syntactically valid code. But "valid Python" isn't the same as "correct TxScript".</p>

      <p>TxScript has nuanced conventions: field access patterns, required vs. non-required handling, multivalue iteration, related object access. I could incorporate this as a skill, but why maintain a parallel implementation when the Formula Field Copilot already exists?</p>

      <p>The solution was obvious: <strong>re-use what already works in production</strong>.</p>

      <ol style="margin: 1rem 0 1.5rem 1.5rem;">
        <li><strong>The User</strong> asks for a business rule in plain English: "Add a 'Net Terms' field that computes Due Date minus Issue Date and categorizes it as Net 15, Net 30, or Outstanding."</li>
        <li><strong>Opus</strong> interprets the intent, fetches the current schema, and derives a structured <code>hint</code> for the Formula Field Copilot.</li>
        <li><strong>The Formula Field Copilot</strong> generates the precise extraction formula in Rossum's syntax.</li>
        <li><strong>Opus</strong> validates the formula against the schema and applies it via MCP tools.</li>
      </ol>

      <p>This mirrors <a href="#section-4">Section 4</a>'s sub-agent pattern, but with a difference: sub-agents delegate for context isolation; here, delegation is for capability. Opus reasons and orchestrates; the Copilot writes formulas. Trying to make Opus do both would mean worse results at higher cost.</p>

      <figure class="content-image">
        <img src="../images/fabry_extension.png" alt="Mr. Fabry configuring duplicate detection through natural conversation" loading="lazy">
        <figcaption>The agent configuring duplicate detection through natural conversation</figcaption>
      </figure>

      <p>It's LLMs all the way down. The frontier model reasons; the production-tested Copilot executes. Neither tries to be something it isn't.</p>

      <div class="takeaway"><strong>Takeaway:</strong> Don't rebuild what already works. If you have a production system that solves a problem, expose it as a tool rather than teaching your agent from scratch.</div>

      <h2 id="section-conclusion">What's Next</h2>

      <p>Remember that 70% prompt reduction from the intro? It wasn't a one-time win. It was the pattern.</p>

      <p>Every improvement in this post followed the same arc: I added complexity to solve a problem, then removed most of it once I understood what mattered. The system got more capable as it got smaller.</p>

      <p>The gap between "works in a demo" and "works for real users" isn't closed by better models. It's closed by subtraction: fewer tools, fewer instructions, fewer responsibilities per agent.</p>

      <p>Next: broader internal rollout at Rossum. More users, more edge cases. I expect to delete as much code in the next 500 commits as I write.</p>

      <p>If you're building agents and want to compare notes, or tell me where I'm wrong, find me on <a href="https://github.com/stancld" target="_blank" rel="noopener">GitHub</a> or <a href="https://x.com/stancld" target="_blank" rel="noopener">X</a>. The lessons are in the diffs. Most are deletions.</p>

      <div class="cta-box">
        <p>All PRs are in the <a href="https://github.com/stancld/rossum-agents" target="_blank" rel="noopener">rossum-agents repository</a>. Open the diffs to see the trade-offs and the backtracking.</p>
        <a href="https://github.com/stancld/rossum-agents" class="cta-button" target="_blank" rel="noopener">
          <svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M12 0C5.37 0 0 5.37 0 12c0 5.31 3.435 9.795 8.205 11.385.6.105.825-.255.825-.57 0-.285-.015-1.23-.015-2.235-3.015.555-3.795-.735-4.035-1.41-.135-.345-.72-1.41-1.23-1.695-.42-.225-1.02-.78-.015-.795.945-.015 1.62.87 1.845 1.23 1.08 1.815 2.805 1.305 3.495.99.105-.78.42-1.305.765-1.605-2.67-.3-5.46-1.335-5.46-5.925 0-1.305.465-2.385 1.23-3.225-.12-.3-.54-1.53.12-3.18 0 0 1.005-.315 3.3 1.23.96-.27 1.98-.405 3-.405s2.04.135 3 .405c2.295-1.56 3.3-1.23 3.3-1.23.66 1.65.24 2.88.12 3.18.765.84 1.23 1.905 1.23 3.225 0 4.605-2.805 5.625-5.475 5.925.435.375.81 1.095.81 2.22 0 1.605-.015 2.895-.015 3.3 0 .315.225.69.825.57A12.02 12.02 0 0024 12c0-6.63-5.37-12-12-12z"/></svg>
          Star on GitHub
        </a>
      </div>
    </article>
  </main>

  <footer>
    <div class="container">
      <p class="disclaimer">This is not an official Rossum product. It is a community-developed integration built on top of the Rossum API.</p>
      <p>Built with ðŸ’™ for <a href="https://rossum.ai" target="_blank" rel="noopener">Rossum</a> Â· <a href="https://github.com/stancld/rossum-agents" target="_blank" rel="noopener">Source on GitHub</a> Â· <a href="../">Back to Home</a></p>
    </div>
  </footer>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const header = document.querySelector('body > header');

      window.addEventListener('scroll', () => {
        if (window.pageYOffset > 10) {
          header.classList.add('scrolled');
        } else {
          header.classList.remove('scrolled');
        }
      }, { passive: true });
    });
  </script>
</body>
</html>
