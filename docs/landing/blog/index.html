<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' stop-color='%233F8AE2'/%3E%3Cstop offset='100%25' stop-color='%23AE33EC'/%3E%3C/linearGradient%3E%3C/defs%3E%3Cpath stroke='url(%23g)' d='M1.4,10.8c0,0,1-2.2,3.8-3.8c2.8-1.6,5.2-1.4,5.2-1.4 M6.3,20.4c0,0-1.4-1.9-1.4-5.2s1.4-5.2,1.4-5.2M16.6,21.7c0,0-2.4,0.3-5.2-1.4c-2.8-1.6-3.8-3.8-3.8-3.8 M22.6,13.2c0,0-1,2.2-3.8,3.8c-2.8-1.6-5.2,1.4-5.2,1.4 M17.8,3.6c0,0,1.4,1.9,1.4,5.2c0,3.2-1.4,5.2-1.4,5.2 M7.4,2.3c0,0,2.4-0.3,5.2,1.4c2.8,1.6,3.8,3.8,3.8,3.8'/%3E%3C/svg%3E">
  <title>From Friday Hack to Deployable Agent | Rossum MCP & Agent</title>
  <meta name="description" content="500+ commits later, here's what I learned building a production AI agent&mdash;from sub-agents and skills to dynamic tool loading.">
  <meta property="og:title" content="From Friday Hack to Deployable Agent">
  <meta property="og:description" content="500+ commits later, here's what I learned building a production AI agent.">
  <meta property="og:image" content="https://stancld.github.io/rossum-agents/blog/images/hero-agent-orchestration.png">
  <meta property="og:type" content="article">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="From Friday Hack to Deployable Agent">
  <meta name="twitter:description" content="500+ commits later, here's what I learned building a production AI agent.">
  <meta name="robots" content="index, follow">
  <link rel="canonical" href="https://stancld.github.io/rossum-agents/blog/">
  <style>
    :root {
      --primary: #3F8AE2;
      --primary-dark: #2d6bb8;
      --accent: #AE33EC;
      --gradient: linear-gradient(135deg, #3F8AE2, #AE33EC);
      --text: #1a1a2e;
      --text-muted: #4b5563;
      --bg: #ffffff;
      --bg-alt: #f8fafc;
      --border: #e5e7eb;
      --code-bg: #1e1e2e;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      color: var(--text);
      line-height: 1.7;
      background: var(--bg);
    }

    .container { max-width: 780px; margin: 0 auto; padding: 0 1.5rem; }

    /* Header */
    .skip-link {
      position: absolute;
      top: 0;
      left: 0;
      background: var(--primary);
      color: white;
      padding: 0.5rem 1rem;
      z-index: 200;
      text-decoration: none;
      border-radius: 0 0 0.5rem;
      transform: translateY(-100%);
      transition: transform 0.2s;
    }

    .skip-link:focus { transform: translateY(0); }

    body > header {
      padding: 1rem 0;
      border-bottom: 1px solid var(--border);
      position: sticky;
      top: 0;
      background: rgba(255, 255, 255, 0.8);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      z-index: 100;
    }

    @supports not (backdrop-filter: blur(8px)) {
      body > header {
        background: var(--bg);
      }
    }

    body > header.scrolled {
      box-shadow: 0 1px 8px rgba(0, 0, 0, 0.08);
    }

    nav {
      display: flex;
      justify-content: space-between;
      align-items: center;
      max-width: 1100px;
      margin: 0 auto;
      padding: 0 1.5rem;
    }

    .logo {
      font-weight: 700;
      font-size: 1.25rem;
      background: var(--gradient);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-decoration: none;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .logo-icon { width: 1.5rem; height: 1.5rem; }

    .nav-links { display: flex; gap: 2rem; flex-shrink: 0; }

    .nav-links a {
      color: var(--text-muted);
      text-decoration: none;
      font-size: 0.95rem;
      transition: color 0.2s;
      padding: 0.5rem;
      margin: -0.5rem;
    }

    .nav-links a:hover { color: var(--primary); }

    /* Focus states */
    a:focus, button:focus {
      outline: 2px solid var(--primary);
      outline-offset: 2px;
    }

    /* Article */
    article {
      padding: 3rem 0 4rem;
    }

    .article-header {
      text-align: center;
      margin-bottom: 3rem;
      padding-bottom: 2rem;
      border-bottom: 1px solid var(--border);
    }

    .article-header h1 {
      font-size: 2.5rem;
      font-weight: 700;
      line-height: 1.2;
      margin-bottom: 1rem;
      letter-spacing: -0.02em;
    }

    .article-subtitle {
      font-size: 1.25rem;
      color: var(--text-muted);
      font-style: italic;
    }

    .author-byline {
      font-size: 0.95rem;
      color: var(--text-muted);
      margin-top: 1rem;
    }

    .hero-image {
      margin: 2rem 0 3rem;
      border-radius: 1rem;
      overflow: hidden;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
    }

    .hero-image img {
      width: 100%;
      height: auto;
      display: block;
    }

    /* Content */
    h2 {
      font-size: 1.5rem;
      font-weight: 700;
      margin: 3rem 0 1rem;
      padding-top: 1rem;
      border-top: 1px solid var(--border);
      scroll-margin-top: 5rem;
    }

    h2:first-of-type {
      border-top: none;
      padding-top: 0;
    }

    p {
      margin-bottom: 1.25rem;
      color: var(--text);
    }

    a {
      color: var(--primary);
      text-decoration: none;
    }

    a:hover {
      text-decoration: underline;
    }

    .pr-link {
      display: inline-block;
      background: linear-gradient(135deg, rgba(63, 138, 226, 0.1), rgba(174, 51, 236, 0.1));
      border: 1px solid rgba(63, 138, 226, 0.2);
      padding: 0.35rem 0.75rem;
      border-radius: 6px;
      font-size: 0.85rem;
      font-weight: 500;
      margin-bottom: 1rem;
    }

    pre {
      background: var(--code-bg);
      color: #cdd6f4;
      padding: 1.25rem 1.5rem;
      border-radius: 0.75rem;
      overflow-x: auto;
      font-family: 'SF Mono', Monaco, 'Courier New', monospace;
      font-size: 0.875rem;
      line-height: 1.6;
      margin: 1.5rem 0;
    }

    code {
      font-family: 'SF Mono', Monaco, 'Courier New', monospace;
      font-size: 0.9em;
      background: var(--bg-alt);
      padding: 0.15rem 0.4rem;
      border-radius: 4px;
    }

    pre code {
      background: none;
      padding: 0;
    }

    .code-comment { color: #6c7086; }
    .code-keyword { color: #cba6f7; }
    .code-string { color: #a6e3a1; }
    .code-decorator { color: #f9e2af; }

    /* Badge (matches landing page) */
    .badge {
      display: inline-block;
      background: linear-gradient(135deg, rgba(63, 138, 226, 0.1), rgba(174, 51, 236, 0.1));
      border: 1px solid rgba(63, 138, 226, 0.2);
      padding: 0.5rem 1.25rem;
      border-radius: 9999px;
      font-size: 0.85rem;
      color: var(--primary);
      font-weight: 500;
    }

    .badge.wip {
      background: linear-gradient(135deg, rgba(251, 191, 36, 0.15), rgba(245, 158, 11, 0.15));
      border-color: rgba(245, 158, 11, 0.3);
      color: #b45309;
    }

    /* TL;DR navigation */
    .toc {
      background: linear-gradient(135deg, rgba(63, 138, 226, 0.03), rgba(174, 51, 236, 0.03));
      border: 1px solid var(--border);
      border-radius: 1rem;
      padding: 1.75rem 2rem;
      margin: 0 0 3rem;
      position: relative;
      overflow: hidden;
    }

    .toc::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: var(--gradient);
    }

    .toc h2 {
      font-size: 0.85rem;
      margin: 0 0 1.25rem;
      padding: 0;
      border: none;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.1em;
      font-weight: 600;
    }

    .toc ol {
      margin: 0;
      padding: 0;
      list-style: none;
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 0.5rem 2rem;
      counter-reset: list-item;
    }

    .toc li {
      padding: 0.4rem 0;
      font-size: 0.95rem;
      display: flex;
      align-items: baseline;
      gap: 0.5rem;
    }

    .toc li::before {
      counter-increment: list-item;
      content: counter(list-item);
      font-size: 0.75rem;
      font-weight: 700;
      color: var(--primary);
      background: rgba(63, 138, 226, 0.1);
      width: 1.5rem;
      height: 1.5rem;
      border-radius: 50%;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .toc a {
      color: var(--text);
      text-decoration: none;
      transition: color 0.2s;
    }

    .toc a:hover {
      color: var(--primary);
    }

    @media (max-width: 600px) {
      .toc ol { grid-template-columns: 1fr; }
      .toc { padding: 1.25rem 1.5rem; }
    }

    /* CTA box */
    .cta-box {
      text-align: center;
      margin: 3rem 0 0;
      padding: 2rem;
      background: linear-gradient(135deg, rgba(63, 138, 226, 0.05), rgba(174, 51, 236, 0.05));
      border-radius: 1rem;
      border: 1px solid var(--border);
    }

    .cta-box p {
      color: var(--text-muted);
      font-style: italic;
      margin-bottom: 1.5rem;
    }

    .cta-button {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      background: var(--gradient);
      color: white;
      padding: 0.9rem 2rem;
      border-radius: 9999px;
      font-weight: 500;
      text-decoration: none;
      transition: all 0.2s;
      box-shadow: 0 4px 14px rgba(63, 138, 226, 0.3);
    }

    .cta-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(63, 138, 226, 0.4);
      text-decoration: none;
    }

    .cta-button svg {
      flex-shrink: 0;
    }

    blockquote {
      border-left: 4px solid var(--primary);
      padding: 1rem 1.5rem;
      margin: 2rem 0;
      background: linear-gradient(135deg, rgba(63, 138, 226, 0.05), rgba(174, 51, 236, 0.05));
      border-radius: 0 0.5rem 0.5rem 0;
      font-size: 1.1rem;
      font-style: italic;
      color: var(--text);
    }

    /* Takeaway boxes */
    .takeaway {
      background: var(--bg-alt);
      border: 1px solid var(--border);
      border-radius: 0.75rem;
      padding: 1rem 1.25rem;
      margin: 1.5rem 0;
    }

    .takeaway strong {
      color: var(--primary);
    }

    /* Images */
    .content-image {
      margin: 2rem 0;
      border-radius: 0.75rem;
      overflow: hidden;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
      border: 1px solid var(--border);
    }

    .content-image img {
      width: 100%;
      height: auto;
      display: block;
    }

    .content-image figcaption {
      padding: 0.75rem 1rem;
      background: var(--bg-alt);
      font-size: 0.9rem;
      color: var(--text-muted);
      text-align: center;
      font-style: italic;
    }

    /* Architecture diagram */
    .arch-diagram {
      background: var(--bg-alt);
      border: 1px solid var(--border);
      border-radius: 0.75rem;
      padding: 1.5rem;
      margin: 1.5rem 0;
      text-align: center;
      font-family: 'SF Mono', Monaco, 'Courier New', monospace;
      font-size: 0.9rem;
      line-height: 1.8;
    }

    .arch-diagram .level-1 { color: var(--primary); font-weight: 600; }
    .arch-diagram .level-2 { color: var(--text-muted); margin-left: 1.5rem; }

    /* Footer */
    footer {
      padding: 3rem 0;
      border-top: 1px solid var(--border);
      text-align: center;
      color: var(--text-muted);
      font-size: 0.9rem;
    }

    footer .disclaimer {
      font-size: 0.85rem;
      font-style: italic;
      margin-bottom: 0.75rem;
      opacity: 0.8;
    }

    footer a {
      color: var(--text-muted);
      text-decoration: underline;
      transition: color 0.2s;
    }

    footer a:hover { color: var(--primary); }

    /* Responsive */
    @media (max-width: 768px) {
      .article-header h1 { font-size: 1.75rem; }
      .article-subtitle { font-size: 1.1rem; }
      h2 { font-size: 1.25rem; }
      pre { font-size: 0.8rem; padding: 1rem; }
      blockquote { padding: 0.75rem 1rem; font-size: 1rem; }
    }

    @media (max-width: 480px) {
      .container { padding: 0 1rem; }
      article { padding: 2rem 0 3rem; }
      .nav-links { gap: 1rem; font-size: 0.9rem; }
    }

    /* Print styles */
    @media print {
      body > header, .skip-link { display: none; }
      body { font-size: 12pt; }
      article { padding: 1rem 0; }
      .hero-image, .content-image { box-shadow: none; border: 1px solid #ccc; }
      .arch-diagram { background: none; border: 1px solid #ccc; }
      pre { white-space: pre-wrap; word-wrap: break-word; }
      a { text-decoration: underline; }
      a[href^="http"]::after { content: " (" attr(href) ")"; font-size: 0.8em; }
    }
  </style>
</head>
<body>
  <a href="#main" class="skip-link">Skip to main content</a>
  <header>
    <nav>
      <a href="../" class="logo" aria-label="Rossum MCP & Agent home">
        <svg class="logo-icon" viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" xmlns="http://www.w3.org/2000/svg">
          <defs>
            <linearGradient id="logo-icon-gradient" x1="0%" y1="0%" x2="100%" y2="100%">
              <stop offset="0%" stop-color="#3F8AE2"/>
              <stop offset="100%" stop-color="#AE33EC"/>
            </linearGradient>
          </defs>
          <path stroke="url(#logo-icon-gradient)" d="M1.4,10.8c0,0,1-2.2,3.8-3.8c2.8-1.6,5.2-1.4,5.2-1.4 M6.3,20.4c0,0-1.4-1.9-1.4-5.2s1.4-5.2,1.4-5.2M16.6,21.7c0,0-2.4,0.3-5.2-1.4c-2.8-1.6-3.8-3.8-3.8-3.8 M22.6,13.2c0,0-1,2.2-3.8,3.8c-2.8,1.6-5.2,1.4-5.2,1.4 M17.8,3.6c0,0,1.4,1.9,1.4,5.2c0,3.2-1.4,5.2-1.4,5.2 M7.4,2.3c0,0,2.4-0.3,5.2,1.4c2.8,1.6,3.8,3.8,3.8,3.8"/>
        </svg>
        Rossum MCP & Agent
      </a>
      <div class="nav-links">
        <a href="https://github.com/stancld/rossum-agents" target="_blank" rel="noopener">GitHub</a>
        <a href="../source/">Docs</a>
        <a href="../">Home</a>
      </div>
    </nav>
  </header>

  <main id="main">
    <article class="container">
      <header class="article-header">
        <h1>From Friday Hack to Deployable Agent</h1>
        <p class="article-subtitle">500+ commits later, here's what I learned.</p>
        <p class="author-byline">By Dan Stancl</p>
        <span class="badge wip">Draft</span>
      </header>

      <figure class="hero-image">
        <img src="./images/hero-agent-orchestration.png" alt="AI Agent orchestration diagram showing how the main agent coordinates with sub-agents, skills, and tools" loading="eager">
      </figure>

      <p><a href="https://rossum.ai" target="_blank" rel="noopener">Rossum</a> is an intelligent document processing platform (invoice capture, purchase orders, structured data extraction). The first version of rossum-agents was a Friday-afternoon project: a small MCP server in JavaScript, a handful of tools, and that hit of dopamine when the LLM successfully called an API. I started naively: upload a document, annotate it, maybe generate a chart from extracted data. That was the pitch.</p>

      <p>Then I started showing it to people.</p>

      <p>I'd test one case, get it working, and excitedly demo it to a Product Manager or Solution Architect. They'd nod, then ask: "Can it also debug this webhook?" or "What about configuring a new queue?" And it would fail, hallucinating a webhook URL or spinning in an infinite loop trying to find a workspace ID that didn't exist. Every conversation revealed another gap. I kept talking to colleagues (PMs, engineers, support), gradually piecing together where the agent could actually help. The goal shifted from flashy demos to <strong>tangible problems</strong>: understanding and documenting workflows, configuring new workspaces, setting up extensions. The boring stuff that actually matters.</p>

      <p>Making an agent work once is easy. Making it work <strong>reliably, for the next person's question</strong>, that's the actual job.</p>

      <p>This post covers the lessons I learned along the way. Each links to a real pull request.</p>

      <nav class="toc" aria-label="Table of contents">
        <h2>Lessons at a Glance</h2>
        <ol>
          <li><a href="#section-1">Declarative Tools</a></li>
          <li><a href="#section-2">From Smolagents to Claude Agent SDK</a></li>
          <li><a href="#section-3">The API that made it usable</a></li>
          <li><a href="#section-4">Sub-Agents: Teaching AI to Delegate</a></li>
          <li><a href="#section-5">Skills: Focused Expertise</a></li>
          <li><a href="#section-6">Dynamic Tool Loading</a></li>
          <li><a href="#section-7">Smarter Models Need Simpler Prompts</a></li>
          <li><a href="#section-8">Regression Testing for Prompts</a></li>
          <li><a href="#section-9">AI Calling AI</a></li>
        </ol>
      </nav>

      <h2 id="section-1">1. From Handlers to Declarative Tools</h2>

      <a href="https://github.com/stancld/rossum-agents/pull/56" class="pr-link" target="_blank" rel="noopener">PR #56</a>

      <p>My first tool layer looked like many backend systems: handler classes inheriting from a base, scattered across 10 files, each with its dedicated registration boilerplate. Adding a new tool meant touching multiple files and asking "where does this logic live again?"</p>

      <p>I replaced it with <strong><a href="https://github.com/jlowin/fastmcp" target="_blank" rel="noopener">FastMCP</a></strong>, a declarative framework where a single decorator defines the entire tool contract:</p>

<pre><span class="code-comment"># Before: manual Tool definition with hand-written JSON schema</span>
<span class="code-keyword">class</span> QueuesHandler(BaseHandler):
    <span class="code-decorator">@classmethod</span>
    <span class="code-keyword">def</span> get_tool_definitions(cls) -> list[Tool]:
        <span class="code-keyword">return</span> [
            Tool(
                name=<span class="code-string">"list_queues"</span>,
                description=<span class="code-string">"List all queues with optional filters."</span>,
                inputSchema={
                    <span class="code-string">"type"</span>: <span class="code-string">"object"</span>,
                    <span class="code-string">"properties"</span>: {
                        <span class="code-string">"workspace_id"</span>: {<span class="code-string">"type"</span>: [<span class="code-string">"integer"</span>, <span class="code-string">"null"</span>]},
                        <span class="code-string">"name"</span>: {<span class="code-string">"type"</span>: [<span class="code-string">"string"</span>, <span class="code-string">"null"</span>]},
                    },
                },
            ),
            ...
        ]</pre>

<pre><span class="code-comment"># After: type hints ARE the schema</span>
<span class="code-decorator">@mcp.tool</span>(description=<span class="code-string">"List all queues with optional filters."</span>)
<span class="code-keyword">async def</span> list_queues(workspace_id: int | None = None, name: str | None = None) -> list[Queue]:
    ...</pre>

      <p>The type hints became the JSON schema the LLM saw. The description became the prompt that told the agent when to use it. FastMCP turned my Python signature into a reliable API contract without me lifting a finger.</p>

      <div class="takeaway"><strong>Takeaway:</strong> -2,011 lines. When types are the schema, there's nothing left to document.</div>

      <h2 id="section-2">2. From Smolagents to the Claude Agent SDK</h2>

      <a href="https://github.com/stancld/rossum-agents/pull/57" class="pr-link" target="_blank" rel="noopener">PR #57</a>

      <p>My initial stack used <strong><a href="https://huggingface.co/docs/smolagents" target="_blank" rel="noopener">smolagents</a></strong> and <strong>LiteLLM</strong>, tools that get an agent running fast. My first working prototype took an afternoon.</p>

      <p>However, as my requirements grew, I needed lower-level control: direct AWS Bedrock integration without routing workarounds, native tool calling without excessive code-execution, and full visibility into system prompts. I also realized I was maintaining 1,500+ lines of custom file and analysis tools that modern Claude models handle natively.</p>

      <p>I migrated to the <strong><a href="https://platform.claude.com/docs/en/agent-sdk/overview" target="_blank" rel="noopener">Claude Agent SDK</a></strong> with direct Bedrock integration, trading quick-start convenience for lower-level control. The SDK handled natively what I'd been maintaining by hand: streaming, tool schemas, and multi-turn context. The result: <strong>~2,800 fewer lines of code</strong> and more capabilities, not fewer.</p>

      <div class="takeaway"><strong>Takeaway:</strong> High-level frameworks accelerate prototyping. When workarounds outnumber features, move closer to the provider SDK.</div>

      <h2 id="section-3">3. The API that made it usable</h2>

      <a href="https://github.com/stancld/rossum-agents/pull/58" class="pr-link" target="_blank" rel="noopener">PR #58</a>

      <p>The CLI was a power-user's dream. But for a support engineer, solution architect, account manager, or anyone chasing an ad-hoc insight for Product, "clone the repo and configure your environment variables" isn't a feature. It's a roadblock. I needed to make it accessible.</p>

      <p>My first attempt was a standalone <strong><a href="https://streamlit.io/" target="_blank" rel="noopener">Streamlit</a></strong> app deployed behind Teleport (Rossum's internal access gateway). It gave users a UI, but introduced new friction: context-switching. Users had to jump between tabs, re-authenticate, and manually bridge the data gap between the agent and the Rossum platform. I was buried in middleware trying to sync JSON Web Tokens (JWTs) and session states across two different domains.</p>

      <p>What actually worked was moving from a sidecar app to a <strong>native integration</strong>.</p>

      <p>I built a dedicated <strong><a href="https://fastapi.tiangolo.com/" target="_blank" rel="noopener">FastAPI</a></strong> backend that became the backbone of the system. It was real engineering work: building production infrastructure, not workarounds. Most importantly, it allowed me to embed the agent directly into the Rossum UI as a chat panel.</p>

      <p>At that point, the agent didn't just "run somewhere." It lived where the work happened. It had the user's context, followed their permissions (using standard Rossum JWTs for row-level security), and eliminated the mental tax of switching interfaces.</p>

      <div class="takeaway"><strong>Takeaway:</strong> If the user has to leave their workflow to use your agent, they'll eventually stop using it.</div>

      <figure class="content-image">
        <img src="../images/fabry_analysis.png" alt="Mr. Fabry analyzing a document workflow, showing queue configuration and active extensions in real-time" loading="lazy">
        <figcaption>The agent explaining queue configuration and active extensions in real-time</figcaption>
      </figure>

      <h2 id="section-4">4. Sub-Agents: Teaching AI to Delegate</h2>

      <a href="https://github.com/stancld/rossum-agents/pull/107" class="pr-link" target="_blank" rel="noopener">PR #107</a>
      <a href="https://code.claude.com/docs/en/sub-agents" class="pr-link" target="_blank" rel="noopener">Sub-Agents</a>

      <p>Early on, I treated the agent like a single specialist locked in a room with every tool I could provide. I assumed that because Rossum is a specialized domain, one well-prompted agent could handle the entire API surface.</p>

      <p>The real issue wasn't domain breadth but <strong>context pollution</strong>. Rossum workflows are defined by large, configurable schemas (tens to hundreds of fields across multiple schemas) which can quickly overwhelm a context window.</p>

      <p>Complex tasks require messy iteration: retrying a failing webhook, patching a schema multiple times, digging through documentation to answer a user's question. In a monolithic architecture, every failed attempt and verbose API error accumulates in the conversation. The noise drowns out the signal, making the agent slower, more prone to hallucination, and more expensive.</p>

      <p>The fix? <strong>Delegation with isolation.</strong></p>

      <p>Sub-agents are separate LLM calls with their own conversation history and a restricted toolset scoped to their specialty. They iterate, fail, and retry in this sandbox while returning only the essential result to the main agent's context, for instance, a summary or a recommendation. This prevents the main agent from ever seeing (or paying for) the 50 lines of API errors it took to get there.</p>

      <p>I chose sub-agents for tasks that either required many retries (like debugging webhooks) or produced verbose intermediate outputs (like knowledge base searches). The primary conversation stays clean:</p>

      <div class="arch-diagram">
        <div class="level-1">Main Agent (Opus 4.5)</div>
        <div class="level-2">â”œâ”€â”€ HookDebugSubAgent (serverless function failures)</div>
        <div class="level-2">â”œâ”€â”€ SchemaPatchingSubAgent (JSON schema modifications)</div>
        <div class="level-2">â””â”€â”€ KnowledgeBaseSubAgent (documentation retrieval)</div>
      </div>

      <p>The implementation is straightforward: sub-agents are exposed as regular tools. Calling <code>debug_hook</code> doesn't run some logic; it spawns an entirely separate LLM session with its own conversation history, a restricted toolset, and a focused system prompt. An abstract base class handles the iteration loop; concrete implementations just define their tools and execution logic. The main agent sees only the final summary; the 15 iterations of trial-and-error stay quarantined.</p>

      <div class="takeaway"><strong>Takeaway:</strong> Sub-agents aren't just for specialization. They're garbage collection for your context window.</div>

      <h2 id="section-5">5. Skills: Focused Expertise on Demand</h2>

      <a href="https://github.com/stancld/rossum-agents/pull/73" class="pr-link" target="_blank" rel="noopener">PR #73</a>
      <a href="https://platform.claude.com/docs/en/agents-and-tools/agent-skills/overview" class="pr-link" target="_blank" rel="noopener">Agent Skills</a>

      <p>Initially, the agent's "brain" was a monolithic system prompt. I kept adding rules, edge cases, and <code>IMPORTANT:</code> blocks in all caps. It felt productive until it became brittle, unreadable, and expensive. Loading every format specification and workflow upfront meant I was paying for tokens the agent didn't even need for 90% of tasks.</p>

      <p>I pivoted to a <strong>Skills Framework</strong> based on <strong>progressive disclosure</strong>: show only what's necessary at that moment. Rossum's documentation alone spans hundreds of pages; loading it all upfront would consume half the context window. Instead, the system loads expertise only when it becomes relevant.</p>

      <figure class="content-image">
        <img src="./images/skills-modular.png" alt="Skills as modular units - showing individual skill files that can be loaded on demand" loading="lazy">
        <figcaption>Skills as modular, version-controlled prompt units</figcaption>
      </figure>

<pre>skills/
â”œâ”€â”€ hook-debugging.md       <span class="code-comment"># Debugging serverless hook issues</span>
â”œâ”€â”€ organization-setup.md   <span class="code-comment"># New customer setup with regional templates</span>
â”œâ”€â”€ rossum-deployment.md    <span class="code-comment"># Safe deployment via sandbox with diffs</span>
â”œâ”€â”€ schema-patching.md      <span class="code-comment"># Adding and updating individual fields</span>
â”œâ”€â”€ schema-pruning.md       <span class="code-comment"># Tree-based view for removing unused fields</span>
â””â”€â”€ ui-settings.md          <span class="code-comment"># Configuring annotation list columns</span></pre>

      <p>The system operated in two distinct stages to optimize the context window:</p>
      <ul style="margin: 1rem 0 1.5rem 1.5rem;">
        <li>Metadata (always loaded): short descriptions of each skill. These act as "triggers" so the agent knows what expertise is available.</li>
        <li>Instructions (loaded on demand): the full procedural knowledge injected only when the agent identifies a matching task, i.e., examples, patterns, and constraints.</li>
      </ul>

      <p>If a user asked, "Why is my webhook failing?", the agent identified the <code>hook-debugging</code> metadata and pulled in the full instructions. The knowledge for UI settings and schema patching stayed dormant. This <strong>dynamic focus</strong> kept the agent sharp and the context clean.</p>

      <p>This approach turned capability expansion into a standard software task: create a file, version it, and ship it. It even changed internal culture. Product Managers can now draft or refine skills in Markdown, with engineers reviewing them just like code.</p>

      <div class="takeaway"><strong>Takeaway:</strong> Stop trying to teach the agent everything at once. Give it a table of contents and let it read the chapter it needs.</div>

      <h2 id="section-6">6. Dynamic Tool Loading: Context Is Money</h2>

      <a href="https://github.com/stancld/rossum-agents/pull/108" class="pr-link" target="_blank" rel="noopener">PR #108</a>

      <p>As the toolkit expanded, I hit the "Agent Tax": every tool added to the context window cost tokens, even if it was never called. Loading all 50+ MCP tools upfront burned roughly <strong>8,000 tokens</strong> before the user even typed a word. This was a waste of money and a waste of cognitive load for the model, leading to slower reasoning and higher latency.</p>

      <p>To solve this, I implemented a <strong>Two-Phase Dynamic Loading</strong> strategy:</p>

      <ul style="margin: 1rem 0 1.5rem 1.5rem;">
        <li>Phase 1: Keyword heuristics. When a message arrived, a simple regex scan in Python checked the user's prompt for domain-specific keywords (e.g., "webhook," "schema," "queue"), bypassing the LLM and relying on old-school pattern matching. The system pre-loaded the corresponding tool categories to eliminate "cold-start" delays. The agent started the conversation with the right tools already in hand.</li>
        <li>Phase 2: Just-in-time discovery. For complex or ambiguous requests, the agent used two "meta-tools" to explore the rest of the library:
          <ul style="margin: 0.5rem 0 0 1rem; list-style-type: circle;">
            <li><code>list_tool_categories()</code>: show me the available tool groups.</li>
            <li><code>get_tool_category(name)</code>: load the specific tools for this group.</li>
          </ul>
        </li>
      </ul>

      <p>Now a simple request like "List my queues" loads only the queue-related tools (~800 tokens) instead of the entire 8,000-token library. I observed a <strong>10x reduction</strong> in baseline context usage.</p>

      <p>The real surprise was the impact on quality. With a smaller, more relevant toolset to choose from, the model became significantly more decisive. By removing the "noise" of irrelevant tool definitions, I effectively improved the agent's focus and reduced the likelihood of tool-selection errors.</p>

      <div class="takeaway"><strong>Takeaway:</strong> A crowded context window is a distracted agent. Dynamic loading saves money and improves reasoning.</div>

      <h2 id="section-7">7. Smarter Models Need Simpler Prompts</h2>

      <a href="https://github.com/stancld/rossum-agents/pull/99" class="pr-link" target="_blank" rel="noopener">PR #99</a>
      <a href="https://github.com/anthropics/claude-code/tree/main/plugins/claude-opus-4-5-migration" class="pr-link" target="_blank" rel="noopener">Opus 4.5 Migration Plugin</a>

      <p>Switching models usually feels like a simple configuration change. But moving from Sonnet to <strong>Claude Opus 4.5</strong> taught me that better models require better, and often <em>shorter</em>, instructions. Admitting my prompt had become an over-engineered legal document was a hard pill to swallow.</p>

      <p>The initial migration was rough. Opus fell into the "tool-calling inferno": redundant loops where the model over-analyzed simple tasks, burning tokens without progress. I realized the problem wasn't the model; it was my "legacy" prompts. Building with less capable models had trained me to write exhaustive, hand-holding instructions. Because Opus 4.5 is more literal and responsive, my <code>CRITICAL:</code> and <code>MUST:</code> blocks were being treated as absolute commands to act, even when unnecessary.</p>

      <p>The fix required a fundamental shift: moving from <strong>procedures to goals</strong>.</p>

<pre><span class="code-comment"># Before: 104 lines of step-by-step handholding</span>
### Step 4: Hook Code Debugging with Opus

**MANDATORY**: When debugging Python hook code, you MUST use `debug_hook`.

**CRITICAL: Investigate ALL Issues**
- DO NOT stop at the first issue found
- The Opus sub-agent will exhaustively analyze for ALL issues
- Continue investigating even after fixing one error

### Step 5: Trust and Apply Opus Results
**CRITICAL:**
- When Opus returns fixed code, you MUST trust its findings
- DO NOT second-guess or re-analyze what Opus has investigated
- DO NOT simplify or modify the fixed code Opus provides

<span class="code-comment"># After: 31 lines of goals + constraints</span>
# Hook Debugging Skill

**Goal**: Identify and fix hook issues.

| Tool | Purpose |
|------|---------|
| `search_knowledge_base` | **USE FIRST** - contains extension configs |
| `debug_hook(hook_id, annotation_id)` | Spawns sub-agent for code analysis |

**Constraints**:
- Always search knowledge base first
- Use `debug_hook` for Python code--do not analyze yourself
- Trust `debug_hook` results--do not re-analyze or modify</pre>

      <p>The hook-debugging skill shrunk from 104 lines to 31. I stopped telling Opus <em>how</em> to think and started telling it <em>what the desired outcome</em> looks like.</p>

      <p>By softening the aggressive language and letting the model infer the best path from the available constraints, I eliminated the tool loops. Counter-intuitively, the model became more predictable.</p>

      <div class="takeaway"><strong>Takeaway:</strong> Smarter models need simpler prompts. If your agent is over-triggering tools or getting stuck, you're likely micromanaging it.</div>

      <h2 id="section-8">8. Regression Testing: Prompts Need Tests Too</h2>

      <a href="https://github.com/stancld/rossum-agents/pull/82" class="pr-link" target="_blank" rel="noopener">PR #82</a>

      <p>I learned this the hard way: refactoring a prompt can change system behavior just as drastically as changing business logic. In a complex agentic system, every "improvement" is a potential regression.</p>

      <p>Consider a typical week: Monday, you tweak the system prompt for better clarity. Tuesday, you add a new validation tool. Wednesday, you "optimize" a tool description. By Friday, the agent is hallucinating parameters or skipping critical steps. Without a way to measure <em>precisely</em> what changed, you're debugging by intuition.</p>

      <p>Since intuition doesn't scale, I built an <strong>Evaluation Framework</strong> to treat prompts like code. It ran the agent through realistic scenarios and validated its behavior across multiple dimensions:</p>

<pre>RegressionTestCase(
    name=<span class="code-string">"setup_invoice_queue_with_validation"</span>,
    prompt=<span class="code-string">"Set up Invoice queue with three specific business validation checks..."</span>,
    tool_expectation=ToolExpectation(
        expected_tools=[
            <span class="code-string">"create_queue_from_template"</span>,
            <span class="code-string">"search_knowledge_base"</span>,
            <span class="code-string">"create_hook_from_template"</span>,
        ],
        mode=ToolMatchMode.SUBSET,
    ),
    token_budget=TokenBudget(
        min_total_tokens=60000,  <span class="code-comment"># Guard against "lazy" agent shortcuts</span>
        max_total_tokens=90000,  <span class="code-comment"># Detect infinite loops early</span>
    ),
    success_criteria=SuccessCriteria(
        require_subagent=True,
        max_steps=6,
        custom_checks=[BUSINESS_VALIDATION_HOOK_CHECK],
    ),
)</pre>

      <p>By tracking <strong>tool sequences</strong> and <strong>token budgets</strong>, I caught subtle regressions that a simple "check the output" test would miss. This framework caught three critical regressions during the Opus 4.5 migration and saved me from a "broken" tool description that looked correct but confused the model's selection logic.</p>

      <div class="takeaway"><strong>Takeaway:</strong> If you can't measure the impact of a prompt change, you shouldn't ship it.</div>

      <h2 id="section-9">9. AI Calling AI: The Copilot Integration</h2>

      <a href="https://github.com/stancld/rossum-agents/commit/59e0881" class="pr-link" target="_blank" rel="noopener">Commit 59e0881</a>
      <a href="https://knowledge-base.rossum.ai/docs/formula-fields-in-rossum" class="pr-link" target="_blank" rel="noopener">Formula Fields in Rossum</a>

      <p><a href="#section-4">Section 4</a> introduced sub-agents as a way to delegate complex tasks while keeping the main context clean. This section takes delegation one step further: instead of spawning another instance of the same frontier model, the agent hands off work to an entirely different, <strong>specialized LLM</strong>.</p>

      <p>Rossum uses <a href="https://knowledge-base.rossum.ai/docs/formula-fields-in-rossum" target="_blank" rel="noopener">Formula Fields</a> for computing derived values during document extraction. Formulas are written in <strong><a href="https://pypi.org/project/txscript/" target="_blank" rel="noopener">TxScript</a></strong>, a language based on Python but extended with Rossum-specific functions, variables, and field references. Rossum already has a production <strong>Formula Field Copilot</strong>: an LLM prompted to translate natural language into precise TxScript.</p>

      <p>So why not have Opus generate formulas directly? Since TxScript is Python-based, Opus can write syntactically valid code. But "valid Python" isn't the same as "correct TxScript".</p>

      <p>TxScript has nuanced conventions (different field access patterns, required vs. non-required field handling, multivalue iteration, related object access) that require tens of lines of prompts to explain. I could incorporate this as a skill, but that means maintaining a parallel implementation. The Formula Field Copilot is already maintained by the responsible team. Why duplicate the effort?</p>

      <p>The solution was obvious: <strong>let each model do what it's trained for</strong>.</p>

      <ol style="margin: 1rem 0 1.5rem 1.5rem;">
        <li><strong>The User</strong> asks for a business rule in plain English: "Add a 'Net Terms' field that computes Due Date minus Issue Date and categorizes it as Net 15, Net 30, or Outstanding."</li>
        <li><strong>Opus</strong> interprets the intent, fetches the current schema, and derives a structured <code>hint</code> for the Formula Field Copilot.</li>
        <li><strong>The Formula Field Copilot</strong> generates the precise extraction formula in Rossum's syntax.</li>
        <li><strong>Opus</strong> validates the formula against the schema and applies it via MCP tools.</li>
      </ol>

      <p>This mirrors the sub-agent pattern from <a href="#section-4">Section 4</a>, but with a key difference: sub-agents delegate for <em>context isolation</em>; here, the delegation is for <em>capability</em>. Opus is the better reasoner and orchestrator; the Copilot is the better formula writer. Trying to make Opus do both would mean worse results at higher cost.</p>

      <figure class="content-image">
        <img src="../images/fabry_extension.png" alt="Mr. Fabry configuring duplicate detection through natural conversation" loading="lazy">
        <figcaption>The agent configuring duplicate detection through natural conversation</figcaption>
      </figure>

      <p>It's LLMs all the way down, and that's exactly the point. The frontier model reasons; the specialist executes. Neither tries to be something it isn't.</p>

      <div class="takeaway"><strong>Takeaway:</strong> Frontier models are generalists. When a specialized model already exists for a task, orchestrate it rather than forcing your generalist to learn a new trick.</div>

      <div class="cta-box">
        <p>All PRs referenced are in the <a href="https://github.com/stancld/rossum-agents" target="_blank" rel="noopener">rossum-agents repository</a>. Open the diffs to see the trade-offs, the backtracking, and the moments where the system finally started behaving like something you can trust.</p>
        <a href="https://github.com/stancld/rossum-agents" class="cta-button" target="_blank" rel="noopener">
          <svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M12 0C5.37 0 0 5.37 0 12c0 5.31 3.435 9.795 8.205 11.385.6.105.825-.255.825-.57 0-.285-.015-1.23-.015-2.235-3.015.555-3.795-.735-4.035-1.41-.135-.345-.72-1.41-1.23-1.695-.42-.225-1.02-.78-.015-.795.945-.015 1.62.87 1.845 1.23 1.08 1.815 2.805 1.305 3.495.99.105-.78.42-1.305.765-1.605-2.67-.3-5.46-1.335-5.46-5.925 0-1.305.465-2.385 1.23-3.225-.12-.3-.54-1.53.12-3.18 0 0 1.005-.315 3.3 1.23.96-.27 1.98-.405 3-.405s2.04.135 3 .405c2.295-1.56 3.3-1.23 3.3-1.23.66 1.65.24 2.88.12 3.18.765.84 1.23 1.905 1.23 3.225 0 4.605-2.805 5.625-5.475 5.925.435.375.81 1.095.81 2.22 0 1.605-.015 2.895-.015 3.3 0 .315.225.69.825.57A12.02 12.02 0 0024 12c0-6.63-5.37-12-12-12z"/></svg>
          Star on GitHub
        </a>
      </div>
    </article>
  </main>

  <footer>
    <div class="container">
      <p class="disclaimer">This is not an official Rossum product. It is a community-developed integration built on top of the Rossum API.</p>
      <p>Built with ðŸ’™ for <a href="https://rossum.ai" target="_blank" rel="noopener">Rossum</a> Â· <a href="https://github.com/stancld/rossum-agents" target="_blank" rel="noopener">Source on GitHub</a> Â· <a href="../">Back to Home</a></p>
    </div>
  </footer>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const header = document.querySelector('body > header');

      window.addEventListener('scroll', () => {
        if (window.pageYOffset > 10) {
          header.classList.add('scrolled');
        } else {
          header.classList.remove('scrolled');
        }
      }, { passive: true });
    });
  </script>
</body>
</html>
